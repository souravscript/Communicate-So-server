import { Request, Response } from 'express';
import { ResourceType } from '@prisma/client';
import { createResource, getAllResources, getResourceById, uploadFile } from './resource.service';

export const create = async (req: Request, res: Response) => {
  try {
    const { name, type, url } = req.body;

    if (!name || !type || !url) {
      res.status(400).json({ error: 'Name, type, and URL are required' });
      return;
    }

    // Validate resource type
    if (!Object.values(ResourceType).includes(type as ResourceType)) {
      res.status(400).json({ 
        error: 'Invalid resource type. Must be one of: ' + Object.values(ResourceType).join(', ') 
      });
      return;
    }

    const resource = await createResource({ 
      name, 
      type: type as ResourceType, 
      url 
    });
    res.status(201).json({ message: 'Resource created successfully', resource });
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};

export const uploadFileController = async (req: Request, res: Response) => {
  if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {
    res.status(400).json({ message: 'No files uploaded' });
    return;
  }

  try {
    const files = req.files as Express.Multer.File[];
    const userId = (req as any).userId; // From auth middleware
    const uploadResults = [];

    for (const file of files) {
      const key = file.filename; // Use the filename generated by multer
      await uploadFile(file, key);

      // Determine resource type based on mimetype
      let resourceType: ResourceType = ResourceType.LINK; // Default to LINK
      if (file.mimetype.includes('pdf')) {
        resourceType = ResourceType.PDF;
      } else if (file.mimetype.includes('html') || file.mimetype.includes('text')) {
        resourceType = ResourceType.WEBSITE;
      } else if (file.mimetype.includes('slack')) {
        resourceType = ResourceType.SLACK;
      } else if (file.mimetype.includes('salesforce')) {
        resourceType = ResourceType.SALESFORCE;
      }

      const resource = await createResource({
        name: file.originalname,
        type: resourceType,
        url: `https://${process.env.R2_BUCKET_NAME}.${process.env.R2_ENDPOINT}/${key}`,
      });

      uploadResults.push(resource);
    }

    res.status(200).json({ message: 'Files uploaded successfully', data: uploadResults });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({ message: 'Failed to upload file', error: errorMessage });
  }
};

export const getAll = async (req: Request, res: Response) => {
  try {
    const resources = await getAllResources();
    res.json(resources);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch resources' });
  }
};

export const getById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const resource = await getResourceById(id);
    
    if (!resource) {
      res.status(404).json({ error: 'Resource not found' });
      return;
    }
    
    res.json(resource);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch resource' });
  }
};
